clc ;close all;clear;
I=imread('4.bmp');%读取图片
tempmax=0;%找最大值临时变量
pos=0;%此时灰度位置
J=rgb2gray(I);%灰度化
I1=histeq(J);%自带均衡
figure(1);
subplot(221)
%现实原始图像
title('z')
Jmat=histeq(J);
imshow(Jmat);
h=imhist(Jmat);%计算直方图

subplot(222)
bar(h)%绘制直方图
%imshow(h)
[m,n]=size(J);
b=find(h>(m*n/10000), 1, 'last' );%找到最大的不为阈值的灰度位置
k=zeros(1,256);
k0=zeros(1,256);
for i=2:256%正向计算斜率
   k(i)=(h(i)-h(1))/(i-1); 
end
[~,locMp]=max(k);%找到最大值与位置
Mp=h(locMp);
for i=1:b-1%反向计算斜率
   k0(i)=-(h(i)-h(b))/(i-b); 
end
[~,locNp]=max(k0);%找到最大值与位置
Np=h(locNp);
kl=(Np-Mp)/(locNp-locMp);%L斜率

for i=locMp:locNp
    L=Mp+kl*(i-locMp);
   rd=L-h(i);
   if rd>tempmax
       tempmax=rd;
       pos=i;
   end
end
const1=log( (pos/2+1))/pos;%计算指数系数
const2=9/(255-pos);
const3=1-pos*const2;
J0=double(J);
for i=1:m
    for j=1:n
        if J0(i,j)<=pos
            J0(i,j)=floor(exp((J0(i,j)*const1))-1);
        else 
           J0(i,j)=pos/2+(255-pos/2)*log10((const2*J0(i,j)+const3));
        end
    end
end
ret=uint8(J0);
subplot(223)
imshow(ret,[])

h0=imhist(ret);%计算直方图
subplot(224)
bar(h0)%绘制直方图